{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('curriable'), require('pathington')) : typeof define === 'function' && define.amd ? define(['exports', 'curriable', 'pathington'], factory) : (global = global || self, factory(global.unchanged = {}, global.curriable, global.pathington));\n})(this, function (exports, curriable, pathington) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  function __spreadArrays() {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n    for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n    return r;\n  } // external dependencies\n\n\n  var O = Object;\n  var create = O.create,\n      getOwnPropertySymbols = O.getOwnPropertySymbols,\n      getPrototypeOf = O.getPrototypeOf,\n      keys = O.keys,\n      propertyIsEnumerable = O.propertyIsEnumerable;\n  var isArray = Array.isArray;\n  var toStringFunction = Function.prototype.bind.call(Function.prototype.call, Function.prototype.toString);\n  var toStringObject = Function.prototype.bind.call(Function.prototype.call, O.prototype.toString);\n  /**\r\n   * @constant HAS_SYMBOL_SUPPORT are Symbols supported\r\n   */\n\n  var HAS_SYMBOL_SUPPORT = typeof Symbol === 'function' && typeof Symbol.for === 'function';\n  /**\r\n   * @constant REACT_ELEMENT the symbol / number specific to react elements\r\n   */\n\n  var REACT_ELEMENT = HAS_SYMBOL_SUPPORT ? Symbol.for('react.element') : 0xeac7;\n  /**\r\n   * @function cloneArray\r\n   *\r\n   * @description\r\n   * clone an array to a new array\r\n   *\r\n   * @param array the array to clone\r\n   * @returns the cloned array\r\n   */\n\n  var cloneArray = function (array) {\n    var Constructor = array.constructor;\n    var cloned = Constructor === Array ? [] : new Constructor();\n\n    for (var index = 0, length_1 = array.length; index < length_1; index++) {\n      cloned[index] = array[index];\n    }\n\n    return cloned;\n  };\n  /**\r\n   * @function reduce\r\n   *\r\n   * @description\r\n   * a targeted reduce method faster than the native\r\n   *\r\n   * @param array the array to reduce\r\n   * @param fn the method to reduce each array value with\r\n   * @param initialValue the initial value of the reduction\r\n   * @returns the reduced value\r\n   */\n\n\n  var reduce = function (array, fn, initialValue) {\n    var value = initialValue;\n\n    for (var index = 0, length_2 = array.length; index < length_2; index++) {\n      value = fn(value, array[index]);\n    }\n\n    return value;\n  };\n  /**\r\n   * @function getOwnProperties\r\n   *\r\n   * @description\r\n   * get the all properties (keys and symbols) of the object passed\r\n   *\r\n   * @param object the object to get the properties of\r\n   * @returns the keys and symbols the object has\r\n   */\n\n\n  var getOwnProperties = function (object) {\n    if (!HAS_SYMBOL_SUPPORT) {\n      return keys(object);\n    }\n\n    var ownSymbols = getOwnPropertySymbols(object);\n\n    if (!ownSymbols.length) {\n      return keys(object);\n    }\n\n    return keys(object).concat(reduce(ownSymbols, function (enumerableSymbols, symbol) {\n      if (propertyIsEnumerable.call(object, symbol)) {\n        enumerableSymbols.push(symbol);\n      }\n\n      return enumerableSymbols;\n    }, []));\n  };\n  /**\r\n   * @function assignFallback\r\n   *\r\n   * @description\r\n   * a targeted fallback if native Object.assign is unavailable\r\n   *\r\n   * @param target the object to shallowly merge into\r\n   * @param source the object to shallowly merge into target\r\n   * @returns the shallowly merged object\r\n   */\n\n\n  var assignFallback = function (target, source) {\n    if (!source) {\n      return target;\n    }\n\n    return reduce(getOwnProperties(source), function (clonedObject, property) {\n      clonedObject[property] = source[property];\n      return clonedObject;\n    }, Object(target));\n  };\n\n  var assign = typeof O.assign === 'function' ? O.assign : assignFallback;\n  /**\r\n   * @function createWithProto\r\n   *\r\n   * @description\r\n   * create a new object with the prototype of the object passed\r\n   *\r\n   * @param object object whose prototype will be the new object's prototype\r\n   * @returns object with the prototype of the one passed\r\n   */\n\n  var createWithProto = function (object) {\n    return create(object.__proto__ || getPrototypeOf(object));\n  };\n  /**\r\n   * @function isCloneable\r\n   *\r\n   * @description\r\n   * is the object passed considered cloneable\r\n   *\r\n   * @param object the object that is being checked for cloneability\r\n   * @returns whether the object can be cloned\r\n   */\n\n\n  var isCloneable = function (object) {\n    if (!object || typeof object !== 'object' || object.$$typeof === REACT_ELEMENT) {\n      return false;\n    }\n\n    var type = toStringObject(object);\n    return type !== '[object Date]' && type !== '[object RegExp]';\n  };\n  /**\r\n   * @function isEmptyPath\r\n   *\r\n   * @description\r\n   * is the path passed an empty path\r\n   *\r\n   * @param path the path to check for emptiness\r\n   * @returns whether the path passed is considered empty\r\n   */\n\n\n  var isEmptyPath = function (path) {\n    return path == null || isArray(path) && !path.length;\n  };\n  /**\r\n   * @function isGlobalConstructor\r\n   *\r\n   * @description\r\n   * is the fn passed a global constructor\r\n   *\r\n   * @param fn the fn to check if a global constructor\r\n   * @returns whether the fn passed is a global constructor\r\n   */\n\n\n  var isGlobalConstructor = function (fn) {\n    return typeof fn === 'function' && !!~toStringFunction(fn).indexOf('[native code]');\n  };\n  /**\r\n   * @function callIfFunction\r\n   *\r\n   * @description\r\n   * if the object passed is a function, call it and return its return, else return undefined\r\n   *\r\n   * @param object the object to call if a function\r\n   * @param context the context to call the function with\r\n   * @param parameters the parameters to call the function with\r\n   * @returns the result of the function call, or undefined\r\n   */\n\n\n  var callIfFunction = function (object, context, parameters) {\n    return typeof object === 'function' ? object.apply(context, parameters) : void 0;\n  };\n  /**\r\n   * @function getNewEmptyChild\r\n   *\r\n   * @description\r\n   * get a new empty child object based on the key passed\r\n   *\r\n   * @param key the key to base the empty child on\r\n   * @returns the empty object the child is built from\r\n   */\n\n\n  var getNewEmptyChild = function (key) {\n    return typeof key === 'number' ? [] : {};\n  };\n  /**\r\n   * @function getNewEmptyObject\r\n   *\r\n   * @description\r\n   * get a new empty object based on the object passed\r\n   *\r\n   * @param object the object to base the empty object on\r\n   * @returns an empty version of the object passed\r\n   */\n\n\n  var getNewEmptyObject = function (object) {\n    return isArray(object) ? [] : {};\n  };\n  /**\r\n   * @function getShallowClone\r\n   *\r\n   * @description\r\n   * create a shallow clone of the object passed, respecting its prototype\r\n   *\r\n   * @param object the object to clone\r\n   * @returns a shallow clone of the object passed\r\n   */\n\n\n  var getShallowClone = function (object) {\n    if (object.constructor === O) {\n      return assign({}, object);\n    }\n\n    if (isArray(object)) {\n      return cloneArray(object);\n    }\n\n    return isGlobalConstructor(object.constructor) ? {} : assign(createWithProto(object), object);\n  };\n  /**\r\n   * @function isSameValueZero\r\n   *\r\n   * @description\r\n   * are the values equal based on SameValueZero\r\n   *\r\n   * @param value1 the first value to test\r\n   * @param value2 the second value to test\r\n   * @returns are the two values passed equal based on SameValueZero\r\n   */\n\n\n  var isSameValueZero = function (value1, value2) {\n    return value1 === value2 || value1 !== value1 && value2 !== value2;\n  };\n  /**\r\n   * @function cloneIfPossible\r\n   *\r\n   * @description\r\n   * clone the object if it can be cloned, otherwise return the object itself\r\n   *\r\n   * @param object the object to clone\r\n   * @returns a cloned version of the object, or the object itself if not cloneable\r\n   */\n\n\n  var cloneIfPossible = function (object) {\n    return isCloneable(object) ? getShallowClone(object) : object;\n  };\n  /**\r\n   * @function getCloneOrEmptyObject\r\n   *\r\n   * @description\r\n   * if the object is cloneable, get a clone of the object, else get a new\r\n   * empty child object based on the key\r\n   *\r\n   * @param object the object to clone\r\n   * @param nextKey the key to base the empty child object on\r\n   * @returns a clone of the object, or an empty child object\r\n   */\n\n\n  var getCloneOrEmptyObject = function (object, nextKey) {\n    return isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(nextKey);\n  };\n  /**\r\n   * @function getCoalescedValue\r\n   *\r\n   * @description\r\n   * return the value if not undefined, otherwise return the fallback value\r\n   *\r\n   * @param value the value to coalesce if undefined\r\n   * @param fallbackValue the value to coalesce to\r\n   * @returns the coalesced value\r\n   */\n\n\n  var getCoalescedValue = function (value, fallbackValue) {\n    return value === void 0 ? fallbackValue : value;\n  };\n  /**\r\n   * @function getParsedPath\r\n   *\r\n   * @description\r\n   * parse the path passed into an array path\r\n   *\r\n   * @param path the path to parse\r\n   * @returns the parsed path\r\n   */\n\n\n  var getParsedPath = function (path) {\n    return isArray(path) ? path : pathington.parse(path);\n  };\n  /**\r\n   * @function getCloneAtPath\r\n   *\r\n   * @description\r\n   * get a new object, cloned at the path specified while leveraging\r\n   * structural sharing for the rest of the properties\r\n   *\r\n   * @param path the path to clone at\r\n   * @param object the object with cloned children at path\r\n   * @param onMatch the method to call once the end of the path is reached\r\n   * @param index the path index\r\n   * @returns the object deeply cloned at the path specified\r\n   */\n\n\n  var getCloneAtPath = function (path, object, onMatch, index) {\n    var key = path[index];\n    var nextIndex = index + 1;\n\n    if (nextIndex === path.length) {\n      onMatch(object, key);\n    } else {\n      object[key] = getCloneAtPath(path, getCloneOrEmptyObject(object[key], path[nextIndex]), onMatch, nextIndex);\n    }\n\n    return object;\n  };\n  /**\r\n   * @function getDeepClone\r\n   *\r\n   * @description\r\n   * get a clone of the object at the path specified\r\n   *\r\n   * @param path the path to clone at\r\n   * @param object the object to clone at the path\r\n   * @param onMatch once a patch match is found, the callback to fire\r\n   * @returns the clone of the object at path specified\r\n   */\n\n\n  var getDeepClone = function (path, object, onMatch) {\n    var parsedPath = getParsedPath(path);\n    var topLevelClone = getCloneOrEmptyObject(object, parsedPath[0]);\n\n    if (parsedPath.length === 1) {\n      onMatch(topLevelClone, parsedPath[0]);\n      return topLevelClone;\n    }\n\n    return getCloneAtPath(parsedPath, topLevelClone, onMatch, 0);\n  };\n  /**\r\n   * @function getMergedObject\r\n   *\r\n   * @description\r\n   * merge the source into the target, either deeply or shallowly\r\n   *\r\n   * @param target the object to merge into\r\n   * @param source the object being merged into the target\r\n   * @param isDeep is the merge a deep merge\r\n   * @returns the merged object\r\n   */\n\n\n  var getMergedObject = function (target, source, isDeep) {\n    var isObject1Array = isArray(target);\n\n    if (isObject1Array !== isArray(source) || !isCloneable(target)) {\n      return cloneIfPossible(source);\n    }\n\n    if (isObject1Array) {\n      return target.concat(source);\n    }\n\n    var targetClone = target.constructor === O || isGlobalConstructor(target.constructor) ? {} : createWithProto(target);\n    return reduce(getOwnProperties(source), function (clone, key) {\n      clone[key] = isDeep && isCloneable(source[key]) ? getMergedObject(target[key], source[key], isDeep) : source[key];\n      return clone;\n    }, assign(targetClone, target));\n  };\n  /**\r\n   * @function getValueAtPath\r\n   *\r\n   * @description\r\n   * get the value at the nested property, or the fallback provided\r\n   *\r\n   * @param path the path to get the value from\r\n   * @param object the object to get the value from at path\r\n   * @param noMatchValue the value returned if no match is found\r\n   * @returns the matching value, or the fallback provided\r\n   */\n\n\n  var getValueAtPath = function (path, object, noMatchValue) {\n    var parsedPath = getParsedPath(path);\n\n    if (parsedPath.length === 1) {\n      return object ? getCoalescedValue(object[parsedPath[0]], noMatchValue) : noMatchValue;\n    }\n\n    var ref = object;\n    var key = parsedPath[0];\n\n    for (var index = 0; index < parsedPath.length - 1; index++) {\n      if (!ref || !ref[key]) {\n        return noMatchValue;\n      }\n\n      ref = ref[key];\n      key = parsedPath[index + 1];\n    }\n\n    return ref ? getCoalescedValue(ref[key], noMatchValue) : noMatchValue;\n  };\n  /**\r\n   * @function getFullPath\r\n   *\r\n   * @description\r\n   * get the path to add to, based on the object and fn passed\r\n   *\r\n   * @param path the path to add to\r\n   * @param object the object traversed by the path\r\n   * @param fn the function to transform the retrieved value with\r\n   * @returns the full path to add to\r\n   */\n\n\n  var getFullPath = function (path, object, fn) {\n    var isPathEmpty = isEmptyPath(path);\n    var valueAtPath = isPathEmpty ? object : fn ? fn(getValueAtPath(path, object)) : getValueAtPath(path, object);\n    return isArray(valueAtPath) ? isArray(path) ? path.concat([valueAtPath.length]) : (isPathEmpty ? '' : path) + \"[\" + valueAtPath.length + \"]\" : path;\n  };\n  /**\r\n   * @function splice\r\n   *\r\n   * @description\r\n   * a faster, more targeted version of the native splice\r\n   *\r\n   * @param array the array to remove the value from\r\n   * @param splicedIndex the index of the value to remove\r\n   */\n\n\n  var splice = function (array, splicedIndex) {\n    if (array.length) {\n      var cutoff = array.length - 1;\n      var index = splicedIndex;\n\n      while (index < cutoff) {\n        array[index] = array[index + 1];\n        ++index;\n      }\n\n      array.length = cutoff;\n    }\n  };\n  /**\r\n   * @function throwInvalidFnError\r\n   *\r\n   * @description\r\n   * throw the TypeError based on the invalid handler\r\n   *\r\n   * @throws\r\n   */\n\n\n  var throwInvalidFnError = function () {\n    throw new TypeError('handler passed is not of type \"function\".');\n  };\n\n  var isArray$1 = Array.isArray;\n  var slice = Function.prototype.bind.call(Function.prototype.call, Array.prototype.slice);\n\n  function createCall(isWithHandler) {\n    if (isWithHandler) {\n      return function callWith(fn, path, parameters, object, context) {\n        if (context === void 0) {\n          context = object;\n        }\n\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 5);\n\n        if (isEmptyPath(path)) {\n          return callIfFunction(fn.apply(void 0, __spreadArrays([object], extraArgs)), context, parameters);\n        }\n\n        var value = getValueAtPath(path, object);\n\n        if (value === void 0) {\n          return;\n        }\n\n        var result = fn.apply(void 0, __spreadArrays([value], extraArgs));\n        return callIfFunction(result, context, parameters);\n      };\n    }\n\n    return function call(path, parameters, object, context) {\n      if (context === void 0) {\n        context = object;\n      }\n\n      var callable = isEmptyPath(path) ? object : getValueAtPath(path, object);\n      return callIfFunction(callable, context, parameters);\n    };\n  }\n\n  function createGet(isWithHandler) {\n    if (isWithHandler) {\n      return function getWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 4);\n\n        if (isEmptyPath(path)) {\n          return fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        var value = getValueAtPath(path, object);\n        return value === void 0 ? value : fn.apply(void 0, __spreadArrays([value], extraArgs));\n      };\n    }\n\n    return function get(path, object) {\n      return isEmptyPath(path) ? object : getValueAtPath(path, object);\n    };\n  }\n\n  function createGetOr(isWithHandler) {\n    if (isWithHandler) {\n      return function getWithOr(fn, noMatchValue, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 4);\n\n        if (isEmptyPath(path)) {\n          return fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        var value = getValueAtPath(path, object);\n        return value === void 0 ? noMatchValue : fn.apply(void 0, __spreadArrays([value], extraArgs));\n      };\n    }\n\n    return function getOr(noMatchValue, path, object) {\n      return isEmptyPath(path) ? object : getValueAtPath(path, object, noMatchValue);\n    };\n  }\n\n  function createHas(isWithHandler) {\n    if (isWithHandler) {\n      return function hasWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n\n        if (isEmptyPath(path)) {\n          return !!fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        var value = getValueAtPath(path, object);\n        return value !== void 0 && !!fn.apply(void 0, __spreadArrays([value], extraArgs));\n      };\n    }\n\n    return function has(path, object) {\n      return isEmptyPath(path) ? object != null : getValueAtPath(path, object) !== void 0;\n    };\n  }\n\n  function createIs(isWithHandler) {\n    if (isWithHandler) {\n      return function isWith(fn, path, value, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 4);\n\n        if (isEmptyPath(path)) {\n          return isSameValueZero(fn.apply(void 0, __spreadArrays([object], extraArgs)), value);\n        }\n\n        return isSameValueZero(fn.apply(void 0, __spreadArrays([getValueAtPath(path, object)], extraArgs)), value);\n      };\n    }\n\n    return function is(path, value, object) {\n      var _path = isEmptyPath(path) ? object : getValueAtPath(path, object);\n\n      return isSameValueZero(_path, value);\n    };\n  }\n\n  function createMerge(isWithHandler, isDeep) {\n    if (isWithHandler) {\n      return function mergeWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n\n        if (!isCloneable(object)) {\n          return fn.apply(void 0, __spreadArrays([object], extraArgs));\n        }\n\n        if (isEmptyPath(path)) {\n          var objectToMerge = fn.apply(void 0, __spreadArrays([object], extraArgs));\n          return objectToMerge ? getMergedObject(object, objectToMerge, isDeep) : object;\n        }\n\n        var hasChanged = false;\n        var result = getDeepClone(path, object, function (ref, key) {\n          var objectToMerge = fn.apply(void 0, __spreadArrays([ref[key]], extraArgs));\n\n          if (objectToMerge) {\n            ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n            hasChanged = true;\n          }\n        });\n        return hasChanged ? result : object;\n      };\n    }\n\n    return function merge(path, objectToMerge, object) {\n      if (!isCloneable(object)) {\n        return objectToMerge;\n      }\n\n      return isEmptyPath(path) ? getMergedObject(object, objectToMerge, true) : getDeepClone(path, object, function (ref, key) {\n        ref[key] = getMergedObject(ref[key], objectToMerge, isDeep);\n      });\n    };\n  }\n\n  function createNot(isWithHandler) {\n    var is = createIs(isWithHandler);\n    return function not() {\n      return !is.apply(this, arguments);\n    };\n  }\n\n  function createRemove(isWithHandler) {\n    if (isWithHandler) {\n      return function removeWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n\n        if (isEmptyPath(path)) {\n          var emptyObject = getNewEmptyObject(object);\n          return fn.apply(void 0, __spreadArrays([emptyObject], extraArgs)) ? emptyObject : object;\n        }\n\n        var value = getValueAtPath(path, object);\n        return value !== void 0 && fn.apply(void 0, __spreadArrays([value], extraArgs)) ? getDeepClone(path, object, function (ref, key) {\n          if (isArray$1(ref)) {\n            splice(ref, key);\n          } else {\n            delete ref[key];\n          }\n        }) : object;\n      };\n    }\n\n    return function remove(path, object) {\n      if (isEmptyPath(path)) {\n        return getNewEmptyObject(object);\n      }\n\n      return getValueAtPath(path, object) !== void 0 ? getDeepClone(path, object, function (ref, key) {\n        if (isArray$1(ref)) {\n          splice(ref, key);\n        } else {\n          delete ref[key];\n        }\n      }) : object;\n    };\n  }\n\n  function createSet(isWithHandler) {\n    if (isWithHandler) {\n      return function setWith(fn, path, object) {\n        if (typeof fn !== 'function') {\n          throwInvalidFnError();\n        }\n\n        var extraArgs = slice(arguments, 3);\n        return isEmptyPath(path) ? fn.apply(void 0, __spreadArrays([object], extraArgs)) : getDeepClone(path, object, function (ref, key) {\n          ref[key] = fn.apply(void 0, __spreadArrays([ref[key]], extraArgs));\n        });\n      };\n    }\n\n    return function set(path, value, object) {\n      return isEmptyPath(path) ? value : getDeepClone(path, object, function (ref, key) {\n        ref[key] = value;\n      });\n    };\n  }\n\n  function createAdd(isWithHandler) {\n    var _add = createSet(isWithHandler);\n\n    if (isWithHandler) {\n      return function addWith(fn, path, object) {\n        return _add.apply(this, [fn, getFullPath(path, object, fn), object].concat(slice(arguments, 3)));\n      };\n    }\n\n    return function add(path, value, object) {\n      return _add(getFullPath(path, object), value, object);\n    };\n  } // external dependencies\n\n\n  var add = curriable.curry(createAdd(false));\n  var addWith = curriable.curry(createAdd(true));\n  var assign$1 = curriable.curry(createMerge(false, false));\n  var assignWith = curriable.curry(createMerge(true, false));\n  var call = curriable.curry(createCall(false), 3);\n  var callWith = curriable.curry(createCall(true), 4);\n  var get = curriable.curry(createGet(false));\n  var getOr = curriable.curry(createGetOr(false));\n  var getWith = curriable.curry(createGet(true));\n  var getWithOr = curriable.curry(createGetOr(true));\n  var has = curriable.curry(createHas(false));\n  var hasWith = curriable.curry(createHas(true));\n  var is = curriable.curry(createIs(false));\n  var isWith = curriable.curry(createIs(true));\n  var merge = curriable.curry(createMerge(false, true));\n  var mergeWith = curriable.curry(createMerge(true, true));\n  var not = curriable.curry(createNot(false));\n  var notWith = curriable.curry(createNot(true));\n  var remove = curriable.curry(createRemove(false));\n  var removeWith = curriable.curry(createRemove(true));\n  var set = curriable.curry(createSet(false));\n  var setWith = curriable.curry(createSet(true));\n  Object.defineProperty(exports, '__', {\n    enumerable: true,\n    get: function () {\n      return curriable.__;\n    }\n  });\n  exports.add = add;\n  exports.addWith = addWith;\n  exports.assign = assign$1;\n  exports.assignWith = assignWith;\n  exports.call = call;\n  exports.callWith = callWith;\n  exports.get = get;\n  exports.getOr = getOr;\n  exports.getWith = getWith;\n  exports.getWithOr = getWithOr;\n  exports.has = has;\n  exports.hasWith = hasWith;\n  exports.is = is;\n  exports.isWith = isWith;\n  exports.merge = merge;\n  exports.mergeWith = mergeWith;\n  exports.not = not;\n  exports.notWith = notWith;\n  exports.remove = remove;\n  exports.removeWith = removeWith;\n  exports.set = set;\n  exports.setWith = setWith;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}